<?php


namespace MovieSpace\Plugins;

use Exception;
use Phalcon\Events\Event;
use Phalcon\Http\ResponseInterface;
use Phalcon\Mvc\Dispatcher;

/**
 * Class SecurityPlugin
 *
 * This plugin serves as an event handler
 * for events fired by the dispatcher at
 * different times during a request/response
 * lifecycle. Exceptions generated by the
 * web application are also logged here.
 *
 * @package MovieSpace\Plugins
 */
class SecurityPlugin extends PluginBase
{
    /**
     * Define HTTP Error Codes constants
     */
    const CODE_ERROR_APP            = 508;
    const CODE_ERROR_SERVER         = 500;
    const CODE_ERROR_NOT_FOUND      = 404;
    const CODE_ERROR_ACCESS_DENIED  = 401;
    const CODE_SUCCESS              = 200;

    /**
     * Define our public resources/routes
     */
    const PUBLIC_RESOURCES = [
        'index/register',
        'index/index',
        'index/logout',
        'index/health',
        'index/test',
        'index/testMovie',
        'errors/code401',
        'errors/code404',
        'errors/code500',
    ];

    const USER_SESSION_KEY = 'user';
    const ERROR_ROUTE_PREFIX = 'errors/code';

    /**
     * Before handling an external request
     * @param Event $event
     * @param Dispatcher $dispatcher
     * @return bool
     * @throws Exception
     */
    public function beforeHandleRoute(Event $event, Dispatcher $dispatcher)
    {
        // we want to blacklist some ip addresses from
        // making api calls at all
        $ipExcludedList = [
            'debugger.github.io'
        ];

        $clientIp = $this->request->getClientAddress();

        // Block request
        if(in_array($clientIp, $ipExcludedList)) {
            throw new Exception('Access Denied', self::CODE_ERROR_ACCESS_DENIED);

            return false;
        }

        // At this point, every other IP address is allowed
        return true;
    }

    /**
     * Before executing the route...
     *
     * We check to see if a guest is <i>NOT</i> trying
     * to access a <u>public</u> resources
     * @param Event $event
     * @param Dispatcher $dispatcher
     */
    public function beforeExecuteRoute(Event $event, Dispatcher $dispatcher)
    {
        // Log the route...
        $this->_logRoute($dispatcher);
        $user = null;

        // Check if its a logged in user
        if($this->session->has(self::USER_SESSION_KEY)) {

            $user = $this->session->get(self::USER_SESSION_KEY);
            // Add the user object to the view
            $this->view->setVar('user', $user);
        }

        if(is_null($user) && $this->_isPublicResource($dispatcher) == false) {
            throw new Exception('Access Denied', self::CODE_ERROR_ACCESS_DENIED);

            return false;
        }

        return true;
    }

    /**
     * Throws an exception if a web route isn't found...
     * @throws Exception
     */
    public function beforeNotFoundAction()
    {
        throw new Exception('Not Found', self::CODE_ERROR_NOT_FOUND);

        return false;
    }

    /**
     * Handles and logs exceptions generated within
     * the application
     *
     * @param Event $event
     * @param Dispatcher $dispatcher
     * @param Exception $exception
     * @return ResponseInterface
     */
    public function beforeException(Event $event, Dispatcher $dispatcher, Exception $exception)
    {
        // Log the exception
        $this->logger->error(json_encode([
            'code'      => $exception->getCode(),
            'message'   => $exception->getMessage()
        ]));

        // Check if its a HTTP 40(?) error
        if(in_array($exception->getCode(), [ self::CODE_ERROR_ACCESS_DENIED, self::CODE_ERROR_NOT_FOUND])) {
            // Redirect to appropriate handler
            $this->response->redirect(self::ERROR_ROUTE_PREFIX . $exception->getCode());

            // Send request
            return $this->response->send();
        }

        // As for the remain error codes
        if(!in_array($exception->getCode(), [
            self::CODE_SUCCESS, self::CODE_ERROR_SERVER, self::CODE_ERROR_APP
        ])) {
            // Redirect to HTTP 404 handler
            $this->response->redirect(self::ERROR_ROUTE_PREFIX . self::CODE_ERROR_NOT_FOUND);

            // Send request
            return $this->response->send();
        }

        $this->response->redirect(self::ERROR_ROUTE_PREFIX . $exception->getCode());
        return $this->response->send();
    }

    /**
     * Determines the accessibility status
     * of a url route. Returns true if public,
     * else false.
     * @param Dispatcher $dispatcher
     * @return bool
     */
    private function _isPublicResource(Dispatcher $dispatcher)
    {
        $controller = $dispatcher->getControllerName();
        $action = $dispatcher->getActionName();

        $route = $controller . '/' . $action;

        return in_array($route, self::PUBLIC_RESOURCES);
    }

    private function _logRoute(Dispatcher $dispatcher)
    {
        $controller = $dispatcher->getControllerName();
        $action = $dispatcher->getActionName();

        $route = $controller . '/' . $action;

        $this->logger->error('Current Route: ' . $route);
    }


}